synch cpu (instr, load_in, mem_in, cin | stdout, load_out, mem_out, cout)
{
  store mem;
  state int(1) found;

  state int(SIZE) acc;

  state enum(NONE, LD, ST, ADD, MUL, PRT) opcode;
  state int(SIZE) operand;

  # Initial state: wait for instructions.
  start {

    # Set found mem-value to acc.
    on:
      load_in.(value) {
        set acc = [value];
      }

    # Instruction stream.
    elseon:
      instr.(opc, op0) {
        set opcode = [opc], operand = [op0];
        send (act: [1]) => cout;
        goto idecode;
      }
  }

  # Decode instruction opcode.
  idecode {
    on:
      # Load
      cin.(act) & [opcode == LD] {
        set found = [0];
        send @[0] => mem_out;
        goto search;
      }

      # Store
      cin.(act) & [opcode == ST] {
        send (addr: operand || value: [acc]) => mem_out;
        goto start;
      }

      # Addition
      cin.(act) & [opcode == ADD] {
        set acc = [acc + operand];
        goto start;
      }

      # Multiplication
      cin.(act) & [opcode == MUL] {
        set acc = [acc * operand];
        goto start;
      }

      # Print
      cin.(act) & [opcode == PRT] {
        send 'acc => stdout;
        goto start;
      }

      # Error: couldn't decode instruction.
      cin.else {
        send (error: [1]) => stdout;
        goto start;
      }
  }

  search {
    on:
      # Skip.
      mem_in.(addr, value) & [addr != operand] {
        send this => mem_out;
      }

      # Match.
      mem_in.(addr || tail) & [addr == operand] {
        set mem = this,
            found = [1];
        send tail => mem_out;
      }

      # End of list: success
      mem_in.@d & [d == 0 && found == 1] {
        send mem => load_out;
        goto start;
      }

      # End of list: not found
      mem_in.@d & [d == 0 && found == 0] {
        send (error: [1]) => stdout;
        goto start;
      }
  }
}
